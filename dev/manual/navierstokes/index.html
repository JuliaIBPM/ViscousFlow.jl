<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Navier-Stokes systems · ViscousFlow.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ViscousFlow.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href>Navier-Stokes systems</a><ul class="internal"><li><a class="tocitem" href="#Navier-Stokes-without-a-body-1"><span>Navier-Stokes without a body</span></a></li><li><a class="tocitem" href="#Navier-Stokes-with-a-body-1"><span>Navier-Stokes with a body</span></a></li><li><a class="tocitem" href="#Methods-1"><span>Methods</span></a></li><li><a class="tocitem" href="#Index-1"><span>Index</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Navier-Stokes systems</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Navier-Stokes systems</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaIBPM/ViscousFlow.jl/blob/master/docs/src/manual/navierstokes.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Navier-Stokes-systems-1"><a class="docs-heading-anchor" href="#Navier-Stokes-systems-1">Navier-Stokes systems</a><a class="docs-heading-anchor-permalink" href="#Navier-Stokes-systems-1" title="Permalink"></a></h1><div>\[\def\ddt#1{\frac{\mathrm{d}#1}{\mathrm{d}t}}

\renewcommand{\vec}{\boldsymbol}
\newcommand{\uvec}[1]{\vec{\hat{#1}}}
\newcommand{\utangent}{\uvec{\tau}}
\newcommand{\unormal}{\uvec{n}}

\renewcommand{\d}{\,\mathrm{d}}\]</div><p>Here, we will focus on putting tools together from the previous sections in order to set up and solve the Navier-Stokes system of equations. First, we will solve them in a completely unbounded domain (i.e., no bodies), and then we will solve them in the vicinity of a body.</p><h2 id="Navier-Stokes-without-a-body-1"><a class="docs-heading-anchor" href="#Navier-Stokes-without-a-body-1">Navier-Stokes without a body</a><a class="docs-heading-anchor-permalink" href="#Navier-Stokes-without-a-body-1" title="Permalink"></a></h2><p>Here, we seek the solve the two-dimensional incompressible Navier-Stokes equations in their <em>discrete vorticity form</em>, in an unbounded domain:</p><div>\[\ddt w + N(v,w) = \frac{1}{Re} L w,\]</div><p>along with the initial condition</p><div>\[w(0) = w_0.\]</div><p>The field <span>$w$</span> represents the discrete vorticity, which sits at the nodes of the dual cells. The velocity, <span>$v$</span>, lies on the edges of the primal cells. They are related to each other by <span>$v = Cs$</span>, where <span>$s = -L^{-1} w$</span> is the discrete streamfunction.</p><p>The second term on the left-hand side is the convective term, which we have simply written as <span>$N(v,w)$</span>. There are several ways to write this term; here, we will write it by using the discrete divergence,</p><div>\[N(v,w) = D(vw).\]</div><p>The package has a function that is set up to compute this term; we will discuss it below. The right-hand side contains the viscous term, proportional to <span>$1/Re$</span>, where <span>$Re$</span> is the Reynolds number. For this, we will use the integrating factor. For purposes of calculation, it is better to express the problem as</p><div>\[\ddt w - \frac{1}{Re} L w = r_1(w),\]</div><p>where <span>$r_1(w) = -D(vw)$</span>.</p><p>For demonstration, we will solve a problem consisting initially of two identical circular patches of vorticity.</p><p>The first thing we must do is set up a grid. We will make it square, with spacing equal to 0.02 in each cell.</p><pre><code class="language-julia-repl">julia&gt; xlim = (-2,2); ylim = (-2,2);

julia&gt; Δx = 0.02;</code></pre><p>Now we will set the Reynolds number, and set the time step size so that it follows the so-called <em>CFL</em> condition (with CFL number set to 0.5). To be careful, we also make sure the time step size does not exceed a threshold in the grid Fourier number (also set to 0.5):</p><pre><code class="language-julia-repl">julia&gt; Re = 200
200

julia&gt; Δt = min(0.5*Δx,0.5*Δx^2*Re)
0.01</code></pre><p>Now we set up the Navier-Stokes system. This sets the rest of the grid parameters, (number of cells, etc), and creates some some buffer space on the grid.</p><pre><code class="language-julia-repl">julia&gt; sys = NavierStokes(Re,Δx,xlim,ylim,Δt)
Navier-Stokes system on a grid of size 208 x 208</code></pre><p>For example, to check how many dual grid cells we have, we can use the <code>size</code> function, which has been extended to such systems:</p><pre><code class="language-julia-repl">julia&gt; size(sys)
(208, 208)</code></pre><p>Let&#39;s set up a set of dual nodes on this grid:</p><pre><code class="language-julia-repl">julia&gt; w₀ = Nodes(Dual,size(sys));</code></pre><p>The physical grid coordinates of these dual nodes can be generated with the <code>coordinates</code> function:</p><pre><code class="language-julia-repl">julia&gt; xg, yg = coordinates(w₀,dx=cellsize(sys),I0=origin(sys))
(-2.07:0.02:2.07, -2.07:0.02:2.07)</code></pre><p>Now we are ready to set up the integrator for this problem. To account for the viscous diffusion, we need the integrating factor. There are no body constraints to enforce, so we will use the integrating factor Runge-Kutta method (<code>IFRK</code>). For this, we need to set up plans for the integrating factor and for the right-hand side (<span>$r_1$</span>). The package has functions that do both for us, using the system data in <code>sys</code>. We just need to change their argument list so that they fit the template for the <code>IFRK</code> scheme:</p><pre><code class="language-julia-repl">julia&gt; plan_intfact(t,w) = CartesianGrids.plan_intfact(t,w,sys)
plan_intfact (generic function with 1 method)

julia&gt; r₁(w,t) = r₁(w,t,sys)
r₁ (generic function with 1 method)</code></pre><p>Now we can construct the integrator. We will use 3rd-order Runge-Kutta:</p><pre><code class="language-julia-repl">julia&gt; ifrk = IFRK(w₀,sys.Δt,plan_intfact,r₁,rk=ConstrainedSystems.RK31)
ERROR: MethodError: no method matching r₁(::Nodes{Dual,208,208,Float64,Array{Float64,2}}, ::Float64, ::NavierStokes{208,208,0,true})
Closest candidates are:
  r₁(::Any, ::Any) at none:1</code></pre><p>Note that we have only passed in <code>w₀</code> to this scheme to provide the form of data to be used for the state vector in the integrator. It does not matter that the data are still zeros.</p><p>Finally we are ready to solve the problem. We set up the initial condition. It is helpful to define a function first that specifies the vorticity distribution in each vortex patch. We will use a Gaussian:</p><pre><code class="language-julia-repl">julia&gt; using LinearAlgebra

julia&gt; gaussian(x,x0,σ) = exp(-LinearAlgebra.norm(x.-x0)^2/σ^2)/(π*σ^2)
gaussian (generic function with 1 method)</code></pre><p>Now the initial conditions. We will put one vortex at <span>$(-0.5,0)$</span> and the other at <span>$(0.5,0)$</span>. They will each have a strength of <span>$1$</span> and a radius of <span>$0.2$</span>. (Reynolds number is implicitly defined in this problem as <span>$\Gamma/\nu$</span>, where <span>$\nu$</span> is the kinematic viscosity. So there is no point in changing the strength; only the Reynolds number need be varied to explore different mixes of convective and diffusive transport.)</p><pre><code class="language-julia-repl">julia&gt; t = 0.0
0.0

julia&gt; x01 = (-0.5,0); x02 = (0.5,0); σ = 0.2; Γ = 1
1

julia&gt; w₀ .= Δx*[Γ*gaussian((x,y),x01,σ) + Γ*gaussian((x,y),x02,σ) for x in xg, y in yg];

julia&gt; w = deepcopy(w₀);</code></pre><p>Note that we have multiplied the vorticity vector by the grid spacing. This is because the vector <code>w</code> is not actually the vorticity, but rather, a <em>grid</em> vorticity related to velocity through differencing. Let&#39;s plot it to see what we are starting with:</p><pre><code class="language-julia-repl">julia&gt; plot(xg,yg,w)
┌ Warning: Attribute alias `xlim` detected in the user recipe defined for the signature (::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}, ::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}, ::Nodes{Dual,208,208,Float64,Array{Float64,2}}). To ensure expected behavior it is recommended to use the default attribute `xlims`.
└ @ Plots ~/.julia/packages/Plots/sbXPh/src/pipeline.jl:15
┌ Warning: Attribute alias `ratio` detected in the user recipe defined for the signature (::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}, ::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}, ::Nodes{Dual,208,208,Float64,Array{Float64,2}}). To ensure expected behavior it is recommended to use the default attribute `aspect_ratio`.
└ @ Plots ~/.julia/packages/Plots/sbXPh/src/pipeline.jl:15
┌ Warning: Attribute alias `ylim` detected in the user recipe defined for the signature (::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}, ::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}, ::Nodes{Dual,208,208,Float64,Array{Float64,2}}). To ensure expected behavior it is recommended to use the default attribute `ylims`.
└ @ Plots ~/.julia/packages/Plots/sbXPh/src/pipeline.jl:15
Plot{Plots.PyPlotBackend() n=1}</code></pre><p><img src="../w0corotate.svg" alt/></p><p>We will integrate the problem for 1 time unit:</p><pre><code class="language-julia-repl">julia&gt; tf = 1
1

julia&gt; T = 0:Δt:tf
0.0:0.01:1.0</code></pre><p>Now, do it. We will time it to see how long it takes:</p><pre><code class="language-julia-repl">julia&gt; @time for ti in T
           global t, w = ifrk(t,w)
       end
ERROR: UndefVarError: ifrk not defined</code></pre><p>and plot it again:</p><pre><code class="language-julia-repl">julia&gt; plot(xg,yg,w)
┌ Warning: Attribute alias `xlim` detected in the user recipe defined for the signature (::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}, ::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}, ::Nodes{Dual,208,208,Float64,Array{Float64,2}}). To ensure expected behavior it is recommended to use the default attribute `xlims`.
└ @ Plots ~/.julia/packages/Plots/sbXPh/src/pipeline.jl:15
┌ Warning: Attribute alias `ratio` detected in the user recipe defined for the signature (::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}, ::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}, ::Nodes{Dual,208,208,Float64,Array{Float64,2}}). To ensure expected behavior it is recommended to use the default attribute `aspect_ratio`.
└ @ Plots ~/.julia/packages/Plots/sbXPh/src/pipeline.jl:15
┌ Warning: Attribute alias `ylim` detected in the user recipe defined for the signature (::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}, ::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}, ::Nodes{Dual,208,208,Float64,Array{Float64,2}}). To ensure expected behavior it is recommended to use the default attribute `ylims`.
└ @ Plots ~/.julia/packages/Plots/sbXPh/src/pipeline.jl:15
Plot{Plots.PyPlotBackend() n=1}</code></pre><p><img src="../w1corotate.svg" alt/></p><p>Let&#39;s go further!</p><pre><code class="language-julia-repl">julia&gt; tf = 6
6

julia&gt; T = 0:Δt:tf
0.0:0.01:6.0

julia&gt; @time for ti in T
           global t, w = ifrk(t,w)
       end
ERROR: UndefVarError: ifrk not defined</code></pre><pre><code class="language-julia-repl">julia&gt; plot(xg,yg,w)
┌ Warning: Attribute alias `xlim` detected in the user recipe defined for the signature (::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}, ::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}, ::Nodes{Dual,208,208,Float64,Array{Float64,2}}). To ensure expected behavior it is recommended to use the default attribute `xlims`.
└ @ Plots ~/.julia/packages/Plots/sbXPh/src/pipeline.jl:15
┌ Warning: Attribute alias `ratio` detected in the user recipe defined for the signature (::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}, ::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}, ::Nodes{Dual,208,208,Float64,Array{Float64,2}}). To ensure expected behavior it is recommended to use the default attribute `aspect_ratio`.
└ @ Plots ~/.julia/packages/Plots/sbXPh/src/pipeline.jl:15
┌ Warning: Attribute alias `ylim` detected in the user recipe defined for the signature (::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}, ::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}, ::Nodes{Dual,208,208,Float64,Array{Float64,2}}). To ensure expected behavior it is recommended to use the default attribute `ylims`.
└ @ Plots ~/.julia/packages/Plots/sbXPh/src/pipeline.jl:15
Plot{Plots.PyPlotBackend() n=1}</code></pre><p><img src="../w2corotate.svg" alt/></p><h2 id="Navier-Stokes-with-a-body-1"><a class="docs-heading-anchor" href="#Navier-Stokes-with-a-body-1">Navier-Stokes with a body</a><a class="docs-heading-anchor-permalink" href="#Navier-Stokes-with-a-body-1" title="Permalink"></a></h2><p>Now let&#39;s solve for flow past a body. We will solve for the flow past a circular cylinder, a canonical problem in fluid dynamics.</p><p>We will start by constructing the body points,</p><pre><code class="language-julia-repl">julia&gt; n = 100;

julia&gt; body = Bodies.Circle(0.5,n)
ERROR: UndefVarError: Bodies not defined</code></pre><p>We will leave it at the origin. However, to show how we can place it in different orientations, we will construct a rigid-body transformation for demonstration:</p><pre><code class="language-julia-repl">julia&gt; cent = (0.0,0.0)
(0.0, 0.0)

julia&gt; α = 0.0
0.0

julia&gt; T! = RigidTransform(cent,α)
Rigid-body transform
  Translation: (0.0,0.0)
  Rotation angle (rad): 0.0

julia&gt; T!(body)
ERROR: UndefVarError: body not defined</code></pre><p>Now we construct the grid. This time, we will make the grid longer, so that it can resolve part of the wake. (The cylinder will be placed at)</p><pre><code class="language-julia-repl">julia&gt; xlim = (-1,3); ylim = (-1,1);

julia&gt; Δx = 0.02;</code></pre><p>Let&#39;s plot this to see its placement in the domain</p><pre><code class="language-julia-repl">julia&gt; plot(body,xlim=xlim,ylim=ylim)
ERROR: UndefVarError: body not defined</code></pre><p><img src="../cyl0.svg" alt/></p><p>Now we will set the Reynolds number and free stream velocity. Since the problem is scaled by the free stream velocity, we need only set the speed to <span>$1$</span>.</p><pre><code class="language-julia-repl">julia&gt; Re = 200
200

julia&gt; U = 1.0;

julia&gt; U∞ = (U,0.0)
(1.0, 0.0)</code></pre><p>Set the time step size with the usual CFL condition:</p><pre><code class="language-julia-repl">julia&gt; Δt = min(0.5*Δx,0.5*Δx^2*Re)
0.01</code></pre><p>Now set up the body point coordinates in a vector data structure. If we had more than one body, we would assemble all of the bodies&#39; points into this same vector.</p><pre><code class="language-julia-repl">julia&gt; X = VectorData(body.x,body.y);
ERROR: UndefVarError: body not defined</code></pre><p>Create the Navier-Stokes system:</p><pre><code class="language-julia-repl">julia&gt; sys = NavierStokes(Re,Δx,xlim,ylim,Δt,U∞ = U∞, X̃ = X, isstore = true)
ERROR: UndefVarError: X not defined</code></pre><p>Now set up the basic data structures for use in the problem.</p><pre><code class="language-julia-repl">julia&gt; w₀ = Nodes(Dual,size(sys));
ERROR: UndefVarError: sys not defined

julia&gt; f = VectorData(X);
ERROR: UndefVarError: X not defined</code></pre><p>The cylinder flow remains symmetric unless it is explicitly perturbed. We will do this by applying a point perturbation directly in the vorticity, over a short interval centered at <span>$t = 4$</span>.</p><pre><code class="language-julia-repl">julia&gt; xf = (1.5,0.0);

julia&gt; Ff = 10.0;

julia&gt; t0 = 4.0; σ = 1.0;

julia&gt; wforce = PointForce(w₀,xf,Ff,t0,σ,sys)
ERROR: UndefVarError: w₀ not defined</code></pre><p>Now we can set up the integrator. For this, we use <code>IFHERK</code>, since we need both the integrating factor and the constraint applications. We use ready-made functions for each of these. For the right-hand side of the Navier-Stokes equations <code>r₁</code>, we add the point force at time <code>t</code>.</p><pre><code class="language-julia-repl">julia&gt; plan_intfact(t,u) = CartesianGrids.plan_intfact(t,u,sys)
plan_intfact (generic function with 1 method)

julia&gt; plan_constraints(u,t) = ConstrainedSystems.plan_constraints(u,t,sys)
plan_constraints (generic function with 1 method)

julia&gt; r₁(u,t) = ConstrainedSystems.r₁(u,t,sys) + wforce(t)
r₁ (generic function with 1 method)

julia&gt; r₂(u,t) = ConstrainedSystems.r₂(u,t,sys)
r₂ (generic function with 1 method)

julia&gt; @time ifherk = IFHERK(w₀,f,sys.Δt,plan_intfact,plan_constraints,(r₁,r₂),
               rk=ConstrainedSystems.RK31)
ERROR: UndefVarError: sys not defined</code></pre><p>Now set the initial conditions, and initialize some vectors for storing results</p><pre><code class="language-julia-repl">julia&gt; t = 0.0
0.0

julia&gt; u = deepcopy(w₀);
ERROR: UndefVarError: w₀ not defined

julia&gt; fx = Float64[];

julia&gt; fy = Float64[];

julia&gt; thist = Float64[];</code></pre><p>Let&#39;s first integrate just one time unit forward to see the results. We will collect the force data into the <code>fx</code> and <code>fy</code> arrays.</p><pre><code class="language-julia-repl">julia&gt; tf = 1.0;

julia&gt; T = Δt:Δt:tf;

julia&gt; @time for ti in T
           global t, u, f = ifherk(t,u)
       
           push!(thist,t)
           push!(fx,sum(f.u)*Δx^2)
           push!(fy,sum(f.v)*Δx^2)
       end
ERROR: UndefVarError: ifherk not defined</code></pre><p>Plot the solution:</p><pre><code class="language-julia-repl">julia&gt; xg, yg = coordinates(w₀,dx=Δx,I0=origin(sys))
ERROR: UndefVarError: sys not defined

julia&gt; plot(xg,yg,u,levels=range(-0.25,stop=0.25,length=30), color = :RdBu,width=1,
               xlim=(-1+Δx,3-Δx),ylim=(-1+Δx,1-Δx))
ERROR: UndefVarError: xg not defined

julia&gt; plot!(body)
ERROR: UndefVarError: body not defined</code></pre><p><img src="../cyl1.svg" alt/></p><p>The solution is still symmetric because we have not yet applied the perturbation. Advance 4 more units:</p><pre><code class="language-julia-repl">julia&gt; tf = 4.0;

julia&gt; T = Δt:Δt:tf;

julia&gt; @time for ti in T
           global t, u, f = ifherk(t,u)
       
           push!(thist,t)
           push!(fx,sum(f.u)*Δx^2)
           push!(fy,sum(f.v)*Δx^2)
       end
ERROR: UndefVarError: ifherk not defined

julia&gt; plot(xg,yg,u,levels=range(-0.25,stop=0.25,length=30), color = :RdBu, width=1,
               xlim=(-1+Δx,3-Δx),ylim=(-1+Δx,1-Δx))
ERROR: UndefVarError: xg not defined

julia&gt; plot!(body)
ERROR: UndefVarError: body not defined</code></pre><p><img src="../cyl5.svg" alt/></p><p>Now it is losing symmetry after the perturbation has triggered this behavior. Run it several more time units:</p><pre><code class="language-julia-repl">julia&gt; tf = 25.0;

julia&gt; T = Δt:Δt:tf;

julia&gt; @time for ti in T
           global t, u, f = ifherk(t,u)
       
           push!(thist,t)
           push!(fx,sum(f.u)*Δx^2)
           push!(fy,sum(f.v)*Δx^2)
       end
ERROR: UndefVarError: ifherk not defined

julia&gt; plot(xg,yg,u,levels=range(-0.25,stop=0.25,length=30), color = :RdBu,width=1,
               xlim=(-1+Δx,3-Δx),ylim=(-1+Δx,1-Δx))
ERROR: UndefVarError: xg not defined

julia&gt; plot!(body)
ERROR: UndefVarError: body not defined</code></pre><p><img src="../cyl30.svg" alt/></p><p>A full wake now after 30 time units! Plot the force, too:</p><pre><code class="language-julia-repl">julia&gt; plt = plot(layout = (2,1), size = (600, 400))
Plot{Plots.PyPlotBackend() n=0}

julia&gt; plot!(plt[1],thist,2*fy,xlim=(0,30),ylim=(-2,2),xlabel=&quot;Convective time&quot;,ylabel=&quot;\$C_L\$&quot;,legend=false)
Plot{Plots.PyPlotBackend() n=1}

julia&gt; plot!(plt[2],thist,2*fx,xlim=(0,30),ylim=(0,4),xlabel=&quot;Convective time&quot;,ylabel=&quot;\$C_D\$&quot;,legend=false)
Plot{Plots.PyPlotBackend() n=2}

julia&gt; plt
Plot{Plots.PyPlotBackend() n=2}</code></pre><p><img src="../cylforce.svg" alt/></p><h2 id="Methods-1"><a class="docs-heading-anchor" href="#Methods-1">Methods</a><a class="docs-heading-anchor-permalink" href="#Methods-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ViscousFlow.ViscousFlow" href="#ViscousFlow.ViscousFlow"><code>ViscousFlow.ViscousFlow</code></a> — <span class="docstring-category">Module</span></header><section><div><p>The <code>ViscousFlow</code> module is here</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ViscousFlow.jl/blob/b7f278eacf51b2c32faf69305aef0ba615c4a57c/src/ViscousFlow.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ViscousFlow.History" href="#ViscousFlow.History"><code>ViscousFlow.History</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">History(datatype,[;htype::HistoryType = RegularHistory])</code></pre><p>Create an empty history data vector with entries of type <code>datatype</code>. Alternatively, one can pass an example instance of the type of entry. An optional argument <code>htype</code> specifies the type of history vector. By default, this is <code>RegularHistory</code>, but can be alternatively set to <code>PeriodicHistory</code>. In the latter case, if the history vector has length <code>n</code>, then it will be assumed that the <code>n+1</code> entry is identical to the <code>1</code> entry.</p><p>It is important to note that, in order to use the routines for <code>History</code> types, then the element type <code>datatype</code> must be outfitted with basic operations: <code>+</code>, <code>-</code>, scalar multiplication, and <code>fill!</code>.</p><p>Another constructor is <code>History(h::History)</code>, which creates an empty instance of a history of the same type as <code>h</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ViscousFlow.jl/blob/b7f278eacf51b2c32faf69305aef0ba615c4a57c/src/systems/histories.jl#L12-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ViscousFlow.History-Union{Tuple{Array{T,1}}, Tuple{H}, Tuple{T}} where H&lt;:HistoryType where T" href="#ViscousFlow.History-Union{Tuple{Array{T,1}}, Tuple{H}, Tuple{T}} where H&lt;:HistoryType where T"><code>ViscousFlow.History</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">History(data::Vector[;htype=RegularHistory])</code></pre><p>Create a history data vector and fill it with the vector <code>data</code>. The history type can be alternatively specified as <code>RegularHistory</code> (the default) or <code>PeriodicHistory</code> with the <code>htype</code> optional argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ViscousFlow.jl/blob/b7f278eacf51b2c32faf69305aef0ba615c4a57c/src/systems/histories.jl#L40-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ViscousFlow.NavierStokes" href="#ViscousFlow.NavierStokes"><code>ViscousFlow.NavierStokes</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct NavierStokes{NX, NY, N, isstatic}</code></pre><p>A system type that utilizes a grid of <code>NX</code> x <code>NY</code> dual cells and <code>N</code> Lagrange forcing points to solve the discrete Navier-Stokes equations in vorticity form. The parameter <code>isstatic</code> specifies whether the forcing points remain static in the grid.</p><p><strong>Fields</strong></p><ul><li><code>Re</code>: Reynolds number</li><li><code>U∞</code>: Tuple of components of free-stream velocity</li><li><code>Δx</code>: Size of each side of a grid cell</li><li><code>I0</code>: Tuple of indices of the primal node corresponding to physical origin</li><li><code>Δt</code>: Time step</li><li><code>rk</code>: Runge-Kutta coefficients</li><li><code>L</code>: Pre-planned discrete Laplacian operator and inverse</li><li><code>X̃</code>: Lagrange point coordinate data (if present), expressed in inertial coordinates       (if static) or in body-fixed coordinates (if moving)</li><li><code>Hmat</code>: Pre-computed regularization matrix (if present)</li><li><code>Emat</code>: Pre-computed interpolation matrix (if present)</li><li><code>Vb</code>: Buffer space for vector data on Lagrange points</li><li><code>Fq</code>: Buffer space for primal cell edge data</li><li><code>Ww</code>: Buffer space for dual cell edge data</li><li><code>Qq</code>: More buffer space for dual cell edge data</li><li><code>_isstore</code>: flag to specify whether to store regularization/interpolation matrices</li></ul><p><strong>Constructors:</strong></p><p><code>NavierStokes(Re,Δx,xlimits,ylimits,Δt               [,U∞ = (0.0, 0.0)][,X̃ = VectorData{0}()]               [,isstore=false][,isstatic=true][,isfilter=false]               [,rk=ConstrainedSystems.RK31]               [,ddftype=CartesianGrids.Yang3])</code> specifies the Reynolds number <code>Re</code>, the grid               spacing <code>Δx</code>, the dimensions of the domain in the tuples <code>xlimits</code>               and <code>ylimits</code> (excluding the ghost cells), and the time step size <code>Δt</code>.               The other arguments are optional. Note that <code>isstore</code> set to <code>true</code>               would store matrix versions of the operators. This makes the method               faster, at the cost of storage. If <code>isfilter</code> is set to true, then               the regularization relies on a filtered version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ViscousFlow.jl/blob/b7f278eacf51b2c32faf69305aef0ba615c4a57c/src/systems/navier_stokes.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ViscousFlow.StorePlan" href="#ViscousFlow.StorePlan"><code>ViscousFlow.StorePlan</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StorePlan(min_t,max_t,store_Δt,v[;htype=RegularHistory])</code></pre><p>Create a plan for storing history data. The storage of data is specified to start at time unit <code>min_t</code> and to proceed until (and including) <code>max_t</code>, and is stored every <code>store_Δt</code> time units. The list of variables to be stored is specified as a list of variables <code>v</code>. Tuple-type variables are unwrapped into separate storage. The optional argument <code>htype</code> can be used to set the history data to <code>PeriodicHistory</code> or <code>RegularHistory</code> (the default). In the case of <code>PeriodicHistory</code>, the data is assumed to repeat with a period equal to length(history)+1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ViscousFlow.jl/blob/b7f278eacf51b2c32faf69305aef0ba615c4a57c/src/systems/utils.jl#L54-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ViscousFlow.WritePlan" href="#ViscousFlow.WritePlan"><code>ViscousFlow.WritePlan</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">WritePlan(file,write_Δt,varlist)</code></pre><p>Create a plan for writing data to file. The filename <code>file</code> is specified, to be written to every <code>write_Δt</code> time units. The variable names to be written are specified as a vector of strings in <code>varlist</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ViscousFlow.jl/blob/b7f278eacf51b2c32faf69305aef0ba615c4a57c/src/systems/utils.jl#L7-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.cellsize-Tuple{NavierStokes}" href="#CartesianGrids.cellsize-Tuple{NavierStokes}"><code>CartesianGrids.cellsize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cellsize(sys::NavierStokes) -&gt; Float64</code></pre><p>Return the grid cell size of system <code>sys</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ViscousFlow.jl/blob/b7f278eacf51b2c32faf69305aef0ba615c4a57c/src/systems/navier_stokes.jl#L173-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.origin-Tuple{NavierStokes}" href="#CartesianGrids.origin-Tuple{NavierStokes}"><code>CartesianGrids.origin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">origin(sys::NavierStokes) -&gt; Tuple{Int,Int}</code></pre><p>Return a tuple of the indices of the primal node that corresponds to the physical origin of the coordinate system used by <code>sys</code>. Note that these indices need not lie inside the range of indices occupied by the grid. For example, if the range of physical coordinates occupied by the grid is (1.0,3.0) x (2.0,4.0), then the origin is not inside the grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ViscousFlow.jl/blob/b7f278eacf51b2c32faf69305aef0ba615c4a57c/src/systems/navier_stokes.jl#L180-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RigidBodyTools.assign_velocity!-Union{Tuple{N}, Tuple{VectorData{N,T,DT} where DT&lt;:(AbstractArray{T,1} where T) where T,VectorData{N,T,DT} where DT&lt;:(AbstractArray{T,1} where T) where T,BodyList,Array{RigidTransform,1},Array{RigidBodyMotion,1},Real}} where N" href="#RigidBodyTools.assign_velocity!-Union{Tuple{N}, Tuple{VectorData{N,T,DT} where DT&lt;:(AbstractArray{T,1} where T) where T,VectorData{N,T,DT} where DT&lt;:(AbstractArray{T,1} where T) where T,BodyList,Array{RigidTransform,1},Array{RigidBodyMotion,1},Real}} where N"><code>RigidBodyTools.assign_velocity!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">assign_velocity!(V::VectorData,X::VectorData,
                 xc::Real,yc::Real,α::Real,
                 mlist::Vector{RigidBodyMotion},t::Real)</code></pre><p>Assign the components of rigid body velocity for every body (in inertial coordinate system) at time <code>t</code> in the overall data structure <code>V</code>, using coordinates described by <code>X</code> (also in inertial coordinate system), based on array of supplied motion <code>mlist</code> for each body.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ViscousFlow.jl/blob/b7f278eacf51b2c32faf69305aef0ba615c4a57c/src/Systems.jl#L16-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ViscousFlow.initialize_storage-Union{Tuple{StorePlan{H}}, Tuple{H}} where H" href="#ViscousFlow.initialize_storage-Union{Tuple{StorePlan{H}}, Tuple{H}} where H"><code>ViscousFlow.initialize_storage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">initialize_storage(S::StorePlan) -&gt; Vector</code></pre><p>Initialize a storage data stack for the storage plan <code>S</code>. The output is an empty vector of <code>History</code> vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ViscousFlow.jl/blob/b7f278eacf51b2c32faf69305aef0ba615c4a57c/src/systems/utils.jl#L78-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ViscousFlow.set_first_ghost!-Union{Tuple{T}, Tuple{History{T,RegularHistory},History{T,H} where H&lt;:HistoryType}} where T" href="#ViscousFlow.set_first_ghost!-Union{Tuple{T}, Tuple{History{T,RegularHistory},History{T,H} where H&lt;:HistoryType}} where T"><code>ViscousFlow.set_first_ghost!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_first_ghost!(h::History,h_pre::History)</code></pre><p>Set the first ghost value of history <code>h</code> with the last element of history <code>h_pre</code>. This is only valid if <code>h</code> is of type <code>RegularHistory</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ViscousFlow.jl/blob/b7f278eacf51b2c32faf69305aef0ba615c4a57c/src/systems/histories.jl#L123-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ViscousFlow.set_last_ghost!-Union{Tuple{T}, Tuple{History{T,RegularHistory},History{T,H} where H&lt;:HistoryType}} where T" href="#ViscousFlow.set_last_ghost!-Union{Tuple{T}, Tuple{History{T,RegularHistory},History{T,H} where H&lt;:HistoryType}} where T"><code>ViscousFlow.set_last_ghost!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_last_ghost!(h::History,h_post::History)</code></pre><p>Set the last ghost value of history <code>h</code> with the first element of history <code>h_post</code>. This is only valid if <code>h</code> is of type <code>RegularHistory</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ViscousFlow.jl/blob/b7f278eacf51b2c32faf69305aef0ba615c4a57c/src/systems/histories.jl#L132-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ViscousFlow.store_data!-Tuple{Any,Any,StorePlan,Vararg{Any,N} where N}" href="#ViscousFlow.store_data!-Tuple{Any,Any,StorePlan,Vararg{Any,N} where N}"><code>ViscousFlow.store_data!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">store_data!(data,t,S::StorePlan,v)</code></pre><p>Check whether time <code>t</code> is a time for saving for storage as described by plan <code>S</code>, and if so, push the variables specified in <code>v</code> onto the <code>data</code> stack.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ViscousFlow.jl/blob/b7f278eacf51b2c32faf69305aef0ba615c4a57c/src/systems/utils.jl#L93-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size-Union{Tuple{NY}, Tuple{NX}, Tuple{NavierStokes{NX,NY,N,isstatic} where isstatic where N,Int64}} where NY where NX" href="#Base.size-Union{Tuple{NY}, Tuple{NX}, Tuple{NavierStokes{NX,NY,N,isstatic} where isstatic where N,Int64}} where NY where NX"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">size(sys::NavierStokes,d::Int) -&gt; Int</code></pre><p>Return the number of indices of the grid used by <code>sys</code> along dimension <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ViscousFlow.jl/blob/b7f278eacf51b2c32faf69305aef0ba615c4a57c/src/systems/navier_stokes.jl#L159-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size-Union{Tuple{NavierStokes{NX,NY,N,isstatic} where isstatic where N}, Tuple{NY}, Tuple{NX}} where NY where NX" href="#Base.size-Union{Tuple{NavierStokes{NX,NY,N,isstatic} where isstatic where N}, Tuple{NY}, Tuple{NX}} where NY where NX"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">size(sys::NavierStokes) -&gt; Tuple{Int,Int}</code></pre><p>Return a tuple of the number of indices of the grid used by <code>sys</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ViscousFlow.jl/blob/b7f278eacf51b2c32faf69305aef0ba615c4a57c/src/systems/navier_stokes.jl#L166-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FileIO.load-Tuple{WritePlan}" href="#FileIO.load-Tuple{WritePlan}"><code>FileIO.load</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">load(R::WritePlan[,var::String])</code></pre><p>Load the data stored in the file specified by the WritePlan <code>R</code>. If variable <code>var</code> is specified, outputs the specified variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ViscousFlow.jl/blob/b7f278eacf51b2c32faf69305aef0ba615c4a57c/src/systems/utils.jl#L35-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FileIO.save-Tuple{Any,WritePlan,Vararg{Any,N} where N}" href="#FileIO.save-Tuple{Any,WritePlan,Vararg{Any,N} where N}"><code>FileIO.save</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">save(t,R::WritePlan,v)</code></pre><p>Check if time <code>t</code> is appropriate for writing to file, according to the WritePlan <code>R</code>, and if so, write the specified variables <code>v</code> (which may be separated by commas) in <code>R</code> to the file in <code>R</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ViscousFlow.jl/blob/b7f278eacf51b2c32faf69305aef0ba615c4a57c/src/systems/utils.jl#L20-L26">source</a></section></article><h2 id="Index-1"><a class="docs-heading-anchor" href="#Index-1">Index</a><a class="docs-heading-anchor-permalink" href="#Index-1" title="Permalink"></a></h2><ul><li><a href="#ViscousFlow.ViscousFlow"><code>ViscousFlow.ViscousFlow</code></a></li><li><a href="#ViscousFlow.History-Union{Tuple{Array{T,1}}, Tuple{H}, Tuple{T}} where H&lt;:HistoryType where T"><code>ViscousFlow.History</code></a></li><li><a href="#ViscousFlow.History"><code>ViscousFlow.History</code></a></li><li><a href="#ViscousFlow.NavierStokes"><code>ViscousFlow.NavierStokes</code></a></li><li><a href="#ViscousFlow.StorePlan"><code>ViscousFlow.StorePlan</code></a></li><li><a href="#ViscousFlow.WritePlan"><code>ViscousFlow.WritePlan</code></a></li><li><a href="#Base.size-Union{Tuple{NY}, Tuple{NX}, Tuple{NavierStokes{NX,NY,N,isstatic} where isstatic where N,Int64}} where NY where NX"><code>Base.size</code></a></li><li><a href="#Base.size-Union{Tuple{NavierStokes{NX,NY,N,isstatic} where isstatic where N}, Tuple{NY}, Tuple{NX}} where NY where NX"><code>Base.size</code></a></li><li><a href="#CartesianGrids.cellsize-Tuple{NavierStokes}"><code>CartesianGrids.cellsize</code></a></li><li><a href="#CartesianGrids.origin-Tuple{NavierStokes}"><code>CartesianGrids.origin</code></a></li><li><a href="#FileIO.load-Tuple{WritePlan}"><code>FileIO.load</code></a></li><li><a href="#FileIO.save-Tuple{Any,WritePlan,Vararg{Any,N} where N}"><code>FileIO.save</code></a></li><li><a href="#RigidBodyTools.assign_velocity!-Union{Tuple{N}, Tuple{VectorData{N,T,DT} where DT&lt;:(AbstractArray{T,1} where T) where T,VectorData{N,T,DT} where DT&lt;:(AbstractArray{T,1} where T) where T,BodyList,Array{RigidTransform,1},Array{RigidBodyMotion,1},Real}} where N"><code>RigidBodyTools.assign_velocity!</code></a></li><li><a href="#ViscousFlow.initialize_storage-Union{Tuple{StorePlan{H}}, Tuple{H}} where H"><code>ViscousFlow.initialize_storage</code></a></li><li><a href="#ViscousFlow.set_first_ghost!-Union{Tuple{T}, Tuple{History{T,RegularHistory},History{T,H} where H&lt;:HistoryType}} where T"><code>ViscousFlow.set_first_ghost!</code></a></li><li><a href="#ViscousFlow.set_last_ghost!-Union{Tuple{T}, Tuple{History{T,RegularHistory},History{T,H} where H&lt;:HistoryType}} where T"><code>ViscousFlow.set_last_ghost!</code></a></li><li><a href="#ViscousFlow.store_data!-Tuple{Any,Any,StorePlan,Vararg{Any,N} where N}"><code>ViscousFlow.store_data!</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 14 June 2020 06:21">Sunday 14 June 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
